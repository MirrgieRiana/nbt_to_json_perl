#!/usr/bin/env perl

use strict;
use warnings;
use utf8;
use Encode;
use Data::Dumper;
use JSON qw/encode_json decode_json/;

#

my %types = (
	1 => ["byte", "B", \&read_byte],
	2 => ["short", "S", \&read_short],
	3 => ["int", "I", \&read_int],
	4 => ["long", "L", \&read_long],
	5 => ["float", "F", \&read_float],
	6 => ["double", "D", \&read_double],
	7 => ["byte_array", "b", \&read_byte_array],
	8 => ["string", "A", \&read_string],
	9 => ["list", "@", \&read_list],
	10 => ["compound", "%", \&read_compound],
	11 => ["int_array", "i", \&read_int_array],
	12 => ["long_array", "l", \&read_long_array],
);

sub read_data($) {
	my $size = shift;
	if ($size == 0) {
		return "";
	} else {

		my $buffer;
		my $result = read(STDIN, $buffer, $size);

		die "Can not read from STDIN" if $result == 0;
		die "Can not read from STDIN" if ! defined $result;

		return $buffer;
	}
}

sub read_byte() {
	return unpack("c", read_data(1));
}

sub read_short() {
	return unpack("s>", read_data(2));
}

sub read_int() {
	return unpack("l>", read_data(4));
}

sub read_long() {
	return unpack("q>", read_data(8));
}

sub read_float() {
	return unpack("f>", read_data(4));
}

sub read_double() {
	return unpack("d>", read_data(8));
}

sub read_byte_array() {
	my $length = read_int();
	die if $length < 0;
	my @values = map {
		read_byte();
	} 0 .. $length - 1;

	return \@values;
}

sub read_string() {
	my $length = read_short();
	die if $length < 0;
	my $data = read_data($length);
	return decode("utf8", $data);
}

sub read_list() {
	my $type = read_byte();
	my $length = read_int();
	die if $length < 0;
	my @values = map {
		read_payload($type);
	} 0 .. $length - 1;

	return {
		type => $type,
		values => \@values,
	};
}

sub read_compound() {
	my @entries;
	while (1) {
		my $entry = read_entry();
		if ($entry->{type} == 0) {
			last;
		}
		push @entries, $entry;
	}
	return \@entries;
}

sub read_entry() {
	my $type = read_byte();
	if ($type == 0) {
		return {
			type => $type,
		};
	}
	my $key = read_string();
	my $value = read_payload($type);

	return {
		type => $type,
		key => $key,
		value => $value,
	};
}

sub read_int_array() {
	my $length = read_int();
	die if $length < 0;
	my @values = map {
		read_int();
	} 0 .. $length - 1;

	return \@values;
}

sub read_long_array() {
	my $length = read_int();
	die if $length < 0;
	my @values = map {
		read_long();
	} 0 .. $length - 1;

	return \@values;
}

sub read_payload($) {
	my $type = shift;
	my $a = $types{$type};
	die "Unknown Type: $type" if ! defined $a;
	return $a->[2]();
}

#

binmode STDIN;
print JSON->new->canonical->ascii->encode(read_entry()), "\n";
